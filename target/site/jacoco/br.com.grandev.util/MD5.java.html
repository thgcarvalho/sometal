<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MD5.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Sometal WebApp</a> &gt; <a href="index.html" class="el_package">br.com.grandev.util</a> &gt; <span class="el_source">MD5.java</span></div><h1>MD5.java</h1><pre class="source lang-java linenums">package br.com.grandev.util;

/*
 * Copyright (C) 1996 Santeri Paavolainen, Helsinki Finland
 *
 * Copyright (C) 2007 Stu Thompson stu.comp -at- mailworks.org
 *
 * Copyright (C) 2002-2010 Stephen Ostermiller
 * http://ostermiller.org/contact.pl?regarding=Java+Utilities
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * See LICENSE.txt for details.
 *
 * The original work by Santeri Paavolainen can be found at
 * http://santtu.iki.fi/md5/
 *
 * This Java class has been derived from the RSA Data Security, Inc. MD5
 * Message-Digest Algorithm and its reference implementation.
 */
 
import java.io.*;
 
/**
 * MD5 hash generator.
 * More information about this class is available from &lt;a target=&quot;_top&quot; href=
 * &quot;http://ostermiller.org/utils/MD5.html&quot;&gt;ostermiller.org&lt;/a&gt;.
 * &lt;p&gt;
 * This class takes as input a message of arbitrary length and produces
 * as output a 128-bit &quot;fingerprint&quot; or &quot;message digest&quot; of the input.
 * It is conjectured that it is computationally infeasible to produce
 * two messages having the same message digest, or to produce any
 * message having a given pre-specified target message digest. The MD5
 * algorithm is intended for digital signature applications, where a
 * large file must be &quot;compressed&quot; in a secure manner before being
 * encrypted with a private (secret) key under a public-key cryptosystem
 * such as RSA.
 * &lt;p&gt;
 * For more information see RFC1321.
 *
 * @see MD5OutputStream
 * @see MD5InputStream
 *
 * @author Santeri Paavolainen http://santtu.iki.fi/md5/
 * @author Stephen Ostermiller http://ostermiller.org/contact.pl?regarding=Java+Utilities
 * @since ostermillerutils 1.00.00
 */
public class MD5 {
 
    /**
     * Class constructor
     *
     * @since ostermillerutils 1.00.00
     */
<span class="fc" id="L63">    public MD5 () {</span>
<span class="fc" id="L64">        reset();</span>
<span class="fc" id="L65">    }</span>
 
    /**
     * Command line program that will take files as arguments
     * and output the MD5 sum for each file.
     *
     * @param args command line arguments
     *
     * @since ostermillerutils 1.00.00
     */
    public static void main (String[] args){
<span class="nc bnc" id="L76" title="All 2 branches missed.">        if (args.length == 0){</span>
<span class="nc" id="L77">            System.err.println(&quot;Please specify a file.&quot;);</span>
        } else {
<span class="nc bnc" id="L79" title="All 2 branches missed.">            for (String element: args) {</span>
                try {
<span class="nc" id="L81">                    System.out.println(MD5.getHashString(new File(element)) + &quot; &quot; + element);</span>
<span class="nc" id="L82">                } catch (IOException x){</span>
<span class="nc" id="L83">                    System.err.println(x.getMessage());</span>
<span class="nc" id="L84">                }</span>
            }
        }
<span class="nc" id="L87">    }</span>
 
    /**
     * Gets this hash sum as an array of 16 bytes.
     *
     * @return Array of 16 bytes, the hash of all updated bytes.
     *
     * @since ostermillerutils 1.00.00
     */
    public byte[] getHash() {
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        if (!finalState.valid) {</span>
<span class="fc" id="L98">            finalState.copy(workingState);</span>
<span class="fc" id="L99">            long bitCount = finalState.bitCount;</span>
            // Compute the number of left over bits
<span class="fc" id="L101">            int leftOver = (int) (((bitCount &gt;&gt;&gt; 3)) &amp; 0x3f);</span>
            // Compute the amount of padding to add based on number of left over bits.
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">            int padlen = (leftOver &lt; 56) ? (56 - leftOver) : (120 - leftOver);</span>
            // add the padding
<span class="fc" id="L105">            update(finalState, padding, 0, padlen);</span>
            // add the length (computed before padding was added)
<span class="fc" id="L107">            update(finalState, encode(bitCount), 0, 8);</span>
<span class="fc" id="L108">            finalState.valid = true;</span>
        }
        // make a copy of the hash before returning it.
<span class="fc" id="L111">        return encode(finalState.state, 16);</span>
    }
 
    /**
     * Returns 32-character hex representation of this hash.
     *
     * @return String representation of this object's hash.
     *
     * @since ostermillerutils 1.00.00
     */
    public String getHashString(){
<span class="fc" id="L122">        return toHex(this.getHash());</span>
    }
 
    /**
     * Gets the MD5 hash of the given byte array.
     *
     * @param b byte array for which an MD5 hash is desired.
     * @return Array of 16 bytes, the hash of all updated bytes.
     *
     * @since ostermillerutils 1.00.00
     */
    public static byte[] getHash(byte[] b){
<span class="nc" id="L134">        MD5 md5 = new MD5();</span>
<span class="nc" id="L135">        md5.update(b);</span>
<span class="nc" id="L136">        return md5.getHash();</span>
    }
 
    /**
     * Gets the MD5 hash of the given byte array.
     *
     * @param b byte array for which an MD5 hash is desired.
     * @return 32-character hex representation the data's MD5 hash.
     *
     * @since ostermillerutils 1.00.00
     */
    public static String getHashString(byte[] b){
<span class="nc" id="L148">        MD5 md5 = new MD5();</span>
<span class="nc" id="L149">        md5.update(b);</span>
<span class="nc" id="L150">        return md5.getHashString();</span>
    }
 
    /**
     * Gets the MD5 hash the data on the given InputStream.
     *
     * @param in byte array for which an MD5 hash is desired.
     * @return Array of 16 bytes, the hash of all updated bytes.
     * @throws IOException if an I/O error occurs.
     *
     * @since ostermillerutils 1.00.00
     */
    public static byte[] getHash(InputStream in) throws IOException {
<span class="nc" id="L163">        MD5 md5 = new MD5();</span>
<span class="nc" id="L164">        byte[] buffer = new byte[1024];</span>
        int read;
<span class="nc bnc" id="L166" title="All 2 branches missed.">        while ((read = in.read(buffer)) != -1){</span>
<span class="nc" id="L167">            md5.update(buffer, read);</span>
        }
<span class="nc" id="L169">        return md5.getHash();</span>
    }
 
    /**
     * Gets the MD5 hash the data on the given InputStream.
     *
     * @param in byte array for which an MD5 hash is desired.
     * @return 32-character hex representation the data's MD5 hash.
     * @throws IOException if an I/O error occurs.
     *
     * @since ostermillerutils 1.00.00
     */
    public static String getHashString(InputStream in) throws IOException {
<span class="nc" id="L182">        MD5 md5 = new MD5();</span>
<span class="nc" id="L183">        byte[] buffer = new byte[1024];</span>
        int read;
<span class="nc bnc" id="L185" title="All 2 branches missed.">        while ((read = in.read(buffer)) != -1){</span>
<span class="nc" id="L186">            md5.update(buffer, read);</span>
        }
<span class="nc" id="L188">        return md5.getHashString();</span>
    }
 
    /**
     * Gets the MD5 hash of the given file.
     *
     * @param f file for which an MD5 hash is desired.
     * @return Array of 16 bytes, the hash of all updated bytes.
     * @throws IOException if an I/O error occurs.
     *
     * @since ostermillerutils 1.00.00
     */
    public static byte[] getHash(File f) throws IOException {
<span class="nc" id="L201">        InputStream is = new FileInputStream(f);</span>
<span class="nc" id="L202">        byte[] hash = getHash(is);</span>
<span class="nc" id="L203">        is.close();</span>
<span class="nc" id="L204">        return hash;</span>
    }
 
    /**
     * Gets the MD5 hash of the given file.
     *
     * @param f file array for which an MD5 hash is desired.
     * @return 32-character hex representation the data's MD5 hash.
     * @throws IOException if an I/O error occurs.
     *
     * @since ostermillerutils 1.00.00
     */
    public static String getHashString(File f) throws IOException {
<span class="nc" id="L217">        InputStream is = new FileInputStream(f);</span>
<span class="nc" id="L218">        String hash = getHashString(is);</span>
<span class="nc" id="L219">        is.close();</span>
<span class="nc" id="L220">        return hash;</span>
    }
 
    /**
     * Gets the MD5 hash of the given String.
     * The string is converted to bytes using the current
     * platform's default character encoding.
     *
     * @param s String for which an MD5 hash is desired.
     * @return Array of 16 bytes, the hash of all updated bytes.
     *
     * @since ostermillerutils 1.00.00
     */
    public static byte[] getHash(String s){
<span class="fc" id="L234">        MD5 md5 = new MD5();</span>
<span class="fc" id="L235">        md5.update(s);</span>
<span class="fc" id="L236">        return md5.getHash();</span>
    }
 
    /**
     * Gets the MD5 hash of the given String.
     * The string is converted to bytes using the current
     * platform's default character encoding.
     *
     * @param s String for which an MD5 hash is desired.
     * @return 32-character hex representation the data's MD5 hash.
     *
     * @since ostermillerutils 1.00.00
     */
    public static String getHashString(String s){
<span class="nc" id="L250">        MD5 md5 = new MD5();</span>
<span class="nc" id="L251">        md5.update(s);</span>
<span class="nc" id="L252">        return md5.getHashString();</span>
    }
 
 
    /**
     * Gets the MD5 hash of the given String.
     *
     * @param s String for which an MD5 hash is desired.
     * @param enc The name of a supported character encoding.
     * @return Array of 16 bytes, the hash of all updated bytes.
     * @throws UnsupportedEncodingException If the named encoding is not supported.
     *
     * @since ostermillerutils 1.00.00
     */
    public static byte[] getHash(String s, String enc) throws UnsupportedEncodingException {
<span class="nc" id="L267">        MD5 md5 = new MD5();</span>
<span class="nc" id="L268">        md5.update(s, enc);</span>
<span class="nc" id="L269">        return md5.getHash();</span>
    }
 
    /**
     * Gets the MD5 hash of the given String.
     *
     * @param s String for which an MD5 hash is desired.
     * @param enc The name of a supported character encoding.
     * @return 32-character hex representation the data's MD5 hash.
     * @throws UnsupportedEncodingException If the named encoding is not supported.
     *
     * @since ostermillerutils 1.00.00
     */
    public static String getHashString(String s, String enc) throws UnsupportedEncodingException {
<span class="nc" id="L283">        MD5 md5 = new MD5();</span>
<span class="nc" id="L284">        md5.update(s, enc);</span>
<span class="nc" id="L285">        return md5.getHashString();</span>
    }
 
 
    /**
     * Reset the MD5 sum to its initial state.
     *
     * @since ostermillerutils 1.00.00
     */
    public void reset() {
<span class="fc" id="L295">        workingState.reset();</span>
<span class="fc" id="L296">        finalState.valid = false;</span>
<span class="fc" id="L297">    }</span>
 
    /**
     * Returns 32-character hex representation of this hash.
     *
     * @return String representation of this object's hash.
     *
     * @since ostermillerutils 1.00.00
     */
    @Override public String toString(){
<span class="nc" id="L307">        return getHashString();</span>
    }
 
    /**
     * Update this hash with the given data.
     * &lt;p&gt;
     * A state may be passed into this method so that we can add padding
     * and finalize a md5 hash without limiting our ability to update
     * more data later.
     * &lt;p&gt;
     * If length bytes are not available to be hashed, as many bytes as
     * possible will be hashed.
     *
     * @param state Which state is updated.
     * @param buffer Array of bytes to be hashed.
     * @param offset Offset to buffer array.
     * @param length number of bytes to hash.
     *
     * @since ostermillerutils 1.00.00
     */
    private void update (MD5State state, byte buffer[], int offset, int length) {
 
<span class="fc" id="L329">        finalState.valid = false;</span>
 
        // if length goes beyond the end of the buffer, cut it short.
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if ((length + offset) &gt; buffer.length){</span>
<span class="nc" id="L333">            length = buffer.length - offset;</span>
        }
 
        // compute number of bytes mod 64
        // this is what we have sitting in a buffer
        // that have not been hashed yet
<span class="fc" id="L339">        int index = (int) (state.bitCount &gt;&gt;&gt; 3) &amp; 0x3f;</span>
 
        // add the length to the count (translate bytes to bits)
<span class="fc" id="L342">        state.bitCount += length &lt;&lt; 3;</span>
 
<span class="fc" id="L344">        int partlen = 64 - index;</span>
 
<span class="fc" id="L346">        int i = 0;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (length &gt;= partlen) {</span>
<span class="fc" id="L348">            System.arraycopy(buffer, offset, state.buffer, index, partlen);</span>
<span class="fc" id="L349">            transform(state, decode(state.buffer, 64, 0));</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            for (i = partlen; (i + 63) &lt; length; i+= 64){</span>
<span class="nc" id="L351">                transform(state, decode(buffer, 64, i));</span>
            }
<span class="fc" id="L353">            index = 0;</span>
        }
 
        // buffer remaining input
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (i &lt; length) {</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">            for (int start = i; i &lt; length; i++) {</span>
<span class="fc" id="L359">                state.buffer[index + i - start] = buffer[i + offset];</span>
            }
        }
<span class="fc" id="L362">    }</span>
 
    /**
     * Update this hash with the given data.
     * &lt;p&gt;
     * If length bytes are not available to be hashed, as many bytes as
     * possible will be hashed.
     *
     * @param buffer Array of bytes to be hashed.
     * @param offset Offset to buffer array.
     * @param length number of bytes to hash.
     *
     * @since ostermillerutils 1.00.00
     */
    public void update (byte buffer[], int offset, int length) {
<span class="fc" id="L377">        update(workingState, buffer, offset, length);</span>
<span class="fc" id="L378">    }</span>
 
    /**
     * Update this hash with the given data.
     * &lt;p&gt;
     * If length bytes are not available to be hashed, as many bytes as
     * possible will be hashed.
     *
     * @param buffer Array of bytes to be hashed.
     * @param length number of bytes to hash.
     *
     * @since ostermillerutils 1.00.00
     */
    public void update (byte buffer[], int length) {
<span class="nc" id="L392">        update(buffer, 0, length);</span>
<span class="nc" id="L393">    }</span>
 
    /**
     * Update this hash with the given data.
     *
     * @param buffer Array of bytes to be hashed.
     *
     * @since ostermillerutils 1.00.00
     */
    public void update (byte buffer[]) {
<span class="fc" id="L403">        update(buffer, 0, buffer.length);</span>
<span class="fc" id="L404">    }</span>
 
    /**
     * Updates this hash with a single byte.
     *
     * @param b byte to be hashed.
     *
     * @since ostermillerutils 1.00.00
     */
    public void update (byte b) {
<span class="nc" id="L414">        byte buffer[] = new byte[1];</span>
<span class="nc" id="L415">        buffer[0] = b;</span>
<span class="nc" id="L416">        update(buffer, 1);</span>
<span class="nc" id="L417">    }</span>
 
    /**
     * Update this hash with a String.
     * The string is converted to bytes using the current
     * platform's default character encoding.
     *
     * @param s String to be hashed.
     *
     * @since ostermillerutils 1.00.00
     */
    public void update (String s) {
<span class="fc" id="L429">        update(s.getBytes());</span>
<span class="fc" id="L430">    }</span>
 
    /**
     * Update this hash with a String.
     *
     * @param s String to be hashed.
     * @param enc The name of a supported character encoding.
     * @throws UnsupportedEncodingException If the named encoding is not supported.
     *
     * @since ostermillerutils 1.00.00
     */
    public void update (String s, String enc) throws UnsupportedEncodingException {
<span class="nc" id="L442">        update(s.getBytes(enc));</span>
<span class="nc" id="L443">    }</span>
 
    /**
     * The current state from which the hash sum
     * can be computed or updated.
     *
     * @since ostermillerutils 1.00.00
     */
<span class="fc" id="L451">    private MD5State workingState = new MD5State();</span>
 
    /**
     * Cached copy of the final MD5 hash sum.  This is created when
     * the hash is requested and it is invalidated when the hash
     * is updated.
     *
     * @since ostermillerutils 1.00.00
     */
<span class="fc" id="L460">    private MD5State finalState = new MD5State();</span>
 
    /**
     * Temporary buffer cached here for performance reasons.
     *
     * @since ostermillerutils 1.00.00
     */
<span class="fc" id="L467">    private int[] decodeBuffer = new int[16];</span>
 
    /**
     * 64 bytes of padding that can be added if the length
     * is not divisible by 64.
     *
     * @since ostermillerutils 1.00.00
     */
<span class="fc" id="L475">    private static final byte padding[] = {</span>
        (byte) 0x80, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0,
    };
 
    /**
     * Contains internal state of the MD5 class.
     * Passes MD5 test suite as defined in RFC1321.
     *
     * @since ostermillerutils 1.00.00
     */
    private class MD5State {
 
        /**
         * True if this state is valid.
         *
         * @since ostermillerutils 1.00.00
         */
<span class="fc" id="L499">        private boolean valid = true;</span>
 
        /**
         * Reset to initial state.
         *
         * @since ostermillerutils 1.00.00
         */
        private void reset(){
<span class="fc" id="L507">            state[0] = 0x67452301;</span>
<span class="fc" id="L508">            state[1] = 0xefcdab89;</span>
<span class="fc" id="L509">            state[2] = 0x98badcfe;</span>
<span class="fc" id="L510">            state[3] = 0x10325476;</span>
 
<span class="fc" id="L512">            bitCount = 0;</span>
<span class="fc" id="L513">        }</span>
 
        /**
         * 128-byte state
         *
         * @since ostermillerutils 1.00.00
         */
<span class="fc" id="L520">        private int state[] = new int[4];</span>
 
        /**
         * 64-bit count of the number of bits that have been hashed.
         *
         * @since ostermillerutils 1.00.00
         */
        private long bitCount;
 
        /**
         * 64-byte buffer (512 bits) for storing to-be-hashed characters
         *
         * @since ostermillerutils 1.00.00
         */
<span class="fc" id="L534">        private byte buffer[] = new byte[64];</span>
 
<span class="fc" id="L536">        private MD5State() {</span>
<span class="fc" id="L537">            reset();</span>
<span class="fc" id="L538">        }</span>
 
        /**
         * Set this state to be exactly the same as some other.
         *
         * @param from state to copy from.
         *
         * @since ostermillerutils 1.00.00
         */
        private void copy(MD5State from) {
<span class="fc" id="L548">            System.arraycopy(from.buffer, 0, this.buffer, 0, this.buffer.length);</span>
<span class="fc" id="L549">            System.arraycopy(from.state, 0, this.state, 0, this.state.length);</span>
<span class="fc" id="L550">            this.valid = from.valid;</span>
<span class="fc" id="L551">            this.bitCount = from.bitCount;</span>
<span class="fc" id="L552">        }</span>
    }
 
 
    /**
     * Turns array of bytes into string representing each byte as
     * a two digit unsigned hex number.
     *
     * @param hash Array of bytes to convert to hex-string
     * @return  Generated hex string
     *
     * @since ostermillerutils 1.00.00
     */
    private static String toHex(byte hash[]){
<span class="fc" id="L566">        StringBuffer buf = new StringBuffer(hash.length * 2);</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">        for (byte element: hash) {</span>
<span class="fc" id="L568">            int intVal = element &amp; 0xff;</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">            if (intVal &lt; 0x10){</span>
                // append a zero before a one digit hex
                // number to make it two digits.
<span class="fc" id="L572">                buf.append(&quot;0&quot;);</span>
            }
<span class="fc" id="L574">            buf.append(Integer.toHexString(intVal));</span>
        }
<span class="fc" id="L576">        return buf.toString();</span>
    }
 
    private static int FF (int a, int b, int c, int d, int x, int s, int ac) {
<span class="fc" id="L580">        a += ((b &amp; c) | (~b &amp; d));</span>
<span class="fc" id="L581">        a += x;</span>
<span class="fc" id="L582">        a += ac;</span>
        //return rotateLeft(a, s) + b;
<span class="fc" id="L584">        a = (a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s));</span>
<span class="fc" id="L585">        return a + b;</span>
    }
 
    private static int GG (int a, int b, int c, int d, int x, int s, int ac) {
<span class="fc" id="L589">        a += ((b &amp; d) | (c &amp; ~d));</span>
<span class="fc" id="L590">        a += x;</span>
<span class="fc" id="L591">        a += ac;</span>
        //return rotateLeft(a, s) + b;
<span class="fc" id="L593">        a = (a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s));</span>
<span class="fc" id="L594">        return a + b;</span>
    }
 
    private static int HH (int a, int b, int c, int d, int x, int s, int ac) {
<span class="fc" id="L598">        a += (b ^ c ^ d);</span>
<span class="fc" id="L599">        a += x;</span>
<span class="fc" id="L600">        a += ac;</span>
        //return rotateLeft(a, s) + b;
<span class="fc" id="L602">        a = (a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s));</span>
<span class="fc" id="L603">        return a + b;</span>
    }
 
    private static int II (int a, int b, int c, int d, int x, int s, int ac) {
<span class="fc" id="L607">        a += (c ^ (b | ~d));</span>
<span class="fc" id="L608">        a += x;</span>
<span class="fc" id="L609">        a += ac;</span>
        //return rotateLeft(a, s) + b;
<span class="fc" id="L611">        a = (a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s));</span>
<span class="fc" id="L612">        return a + b;</span>
    }
 
    private static byte[] encode(long l){
<span class="fc" id="L616">        byte[] out = new byte[8];</span>
<span class="fc" id="L617">        out[0] = (byte) (l &amp; 0xff);</span>
<span class="fc" id="L618">        out[1] = (byte) ((l &gt;&gt;&gt; 8) &amp; 0xff);</span>
<span class="fc" id="L619">        out[2] = (byte) ((l &gt;&gt;&gt; 16) &amp; 0xff);</span>
<span class="fc" id="L620">        out[3] = (byte) ((l &gt;&gt;&gt; 24) &amp; 0xff);</span>
<span class="fc" id="L621">        out[4] = (byte) ((l &gt;&gt;&gt; 32) &amp; 0xff);</span>
<span class="fc" id="L622">        out[5] = (byte) ((l &gt;&gt;&gt; 40) &amp; 0xff);</span>
<span class="fc" id="L623">        out[6] = (byte) ((l &gt;&gt;&gt; 48) &amp; 0xff);</span>
<span class="fc" id="L624">        out[7] = (byte) ((l &gt;&gt;&gt; 56) &amp; 0xff);</span>
<span class="fc" id="L625">        return out;</span>
    }
 
    private static byte[] encode(int input[], int len){
<span class="fc" id="L629">        byte[] out = new byte[len];</span>
        int i, j;
<span class="fc bfc" id="L631" title="All 2 branches covered.">        for (i = j = 0; j  &lt; len; i++, j += 4) {</span>
<span class="fc" id="L632">            out[j] = (byte) (input[i] &amp; 0xff);</span>
<span class="fc" id="L633">            out[j + 1] = (byte) ((input[i] &gt;&gt;&gt; 8) &amp; 0xff);</span>
<span class="fc" id="L634">            out[j + 2] = (byte) ((input[i] &gt;&gt;&gt; 16) &amp; 0xff);</span>
<span class="fc" id="L635">            out[j + 3] = (byte) ((input[i] &gt;&gt;&gt; 24) &amp; 0xff);</span>
        }
<span class="fc" id="L637">        return out;</span>
    }
 
    private int[] decode(byte buffer[], int len, int offset){
        int i, j;
<span class="fc bfc" id="L642" title="All 2 branches covered.">        for (i = j = 0; j &lt; len; i++, j += 4) {</span>
<span class="fc" id="L643">            decodeBuffer[i] = (</span>
                (buffer[j + offset] &amp; 0xff)) |
                (((buffer[j + 1 + offset] &amp; 0xff)) &lt;&lt; 8) |
                (((buffer[j + 2 + offset] &amp; 0xff)) &lt;&lt; 16) |
                (((buffer[j + 3 + offset] &amp; 0xff)) &lt;&lt; 24
            );
        }
<span class="fc" id="L650">        return decodeBuffer;</span>
    }
 
    private static void transform(MD5State state, int[] x){
<span class="fc" id="L654">        int a = state.state[0];</span>
<span class="fc" id="L655">        int b = state.state[1];</span>
<span class="fc" id="L656">        int c = state.state[2];</span>
<span class="fc" id="L657">        int d = state.state[3];</span>
 
        /* Round 1 */
<span class="fc" id="L660">        a = FF (a, b, c, d, x[ 0],   7, 0xd76aa478); /* 1 */</span>
<span class="fc" id="L661">        d = FF (d, a, b, c, x[ 1],  12, 0xe8c7b756); /* 2 */</span>
<span class="fc" id="L662">        c = FF (c, d, a, b, x[ 2],  17, 0x242070db); /* 3 */</span>
<span class="fc" id="L663">        b = FF (b, c, d, a, x[ 3],  22, 0xc1bdceee); /* 4 */</span>
<span class="fc" id="L664">        a = FF (a, b, c, d, x[ 4],   7, 0xf57c0faf); /* 5 */</span>
<span class="fc" id="L665">        d = FF (d, a, b, c, x[ 5],  12, 0x4787c62a); /* 6 */</span>
<span class="fc" id="L666">        c = FF (c, d, a, b, x[ 6],  17, 0xa8304613); /* 7 */</span>
<span class="fc" id="L667">        b = FF (b, c, d, a, x[ 7],  22, 0xfd469501); /* 8 */</span>
<span class="fc" id="L668">        a = FF (a, b, c, d, x[ 8],   7, 0x698098d8); /* 9 */</span>
<span class="fc" id="L669">        d = FF (d, a, b, c, x[ 9],  12, 0x8b44f7af); /* 10 */</span>
<span class="fc" id="L670">        c = FF (c, d, a, b, x[10],  17, 0xffff5bb1); /* 11 */</span>
<span class="fc" id="L671">        b = FF (b, c, d, a, x[11],  22, 0x895cd7be); /* 12 */</span>
<span class="fc" id="L672">        a = FF (a, b, c, d, x[12],   7, 0x6b901122); /* 13 */</span>
<span class="fc" id="L673">        d = FF (d, a, b, c, x[13],  12, 0xfd987193); /* 14 */</span>
<span class="fc" id="L674">        c = FF (c, d, a, b, x[14],  17, 0xa679438e); /* 15 */</span>
<span class="fc" id="L675">        b = FF (b, c, d, a, x[15],  22, 0x49b40821); /* 16 */</span>
 
        /* Round 2 */
<span class="fc" id="L678">        a = GG (a, b, c, d, x[ 1],   5, 0xf61e2562); /* 17 */</span>
<span class="fc" id="L679">        d = GG (d, a, b, c, x[ 6],   9, 0xc040b340); /* 18 */</span>
<span class="fc" id="L680">        c = GG (c, d, a, b, x[11],  14, 0x265e5a51); /* 19 */</span>
<span class="fc" id="L681">        b = GG (b, c, d, a, x[ 0],  20, 0xe9b6c7aa); /* 20 */</span>
<span class="fc" id="L682">        a = GG (a, b, c, d, x[ 5],   5, 0xd62f105d); /* 21 */</span>
<span class="fc" id="L683">        d = GG (d, a, b, c, x[10],   9, 0x02441453); /* 22 */</span>
<span class="fc" id="L684">        c = GG (c, d, a, b, x[15],  14, 0xd8a1e681); /* 23 */</span>
<span class="fc" id="L685">        b = GG (b, c, d, a, x[ 4],  20, 0xe7d3fbc8); /* 24 */</span>
<span class="fc" id="L686">        a = GG (a, b, c, d, x[ 9],   5, 0x21e1cde6); /* 25 */</span>
<span class="fc" id="L687">        d = GG (d, a, b, c, x[14],   9, 0xc33707d6); /* 26 */</span>
<span class="fc" id="L688">        c = GG (c, d, a, b, x[ 3],  14, 0xf4d50d87); /* 27 */</span>
<span class="fc" id="L689">        b = GG (b, c, d, a, x[ 8],  20, 0x455a14ed); /* 28 */</span>
<span class="fc" id="L690">        a = GG (a, b, c, d, x[13],   5, 0xa9e3e905); /* 29 */</span>
<span class="fc" id="L691">        d = GG (d, a, b, c, x[ 2],   9, 0xfcefa3f8); /* 30 */</span>
<span class="fc" id="L692">        c = GG (c, d, a, b, x[ 7],  14, 0x676f02d9); /* 31 */</span>
<span class="fc" id="L693">        b = GG (b, c, d, a, x[12],  20, 0x8d2a4c8a); /* 32 */</span>
 
        /* Round 3 */
<span class="fc" id="L696">        a = HH (a, b, c, d, x[ 5],   4, 0xfffa3942); /* 33 */</span>
<span class="fc" id="L697">        d = HH (d, a, b, c, x[ 8],  11, 0x8771f681); /* 34 */</span>
<span class="fc" id="L698">        c = HH (c, d, a, b, x[11],  16, 0x6d9d6122); /* 35 */</span>
<span class="fc" id="L699">        b = HH (b, c, d, a, x[14],  23, 0xfde5380c); /* 36 */</span>
<span class="fc" id="L700">        a = HH (a, b, c, d, x[ 1],   4, 0xa4beea44); /* 37 */</span>
<span class="fc" id="L701">        d = HH (d, a, b, c, x[ 4],  11, 0x4bdecfa9); /* 38 */</span>
<span class="fc" id="L702">        c = HH (c, d, a, b, x[ 7],  16, 0xf6bb4b60); /* 39 */</span>
<span class="fc" id="L703">        b = HH (b, c, d, a, x[10],  23, 0xbebfbc70); /* 40 */</span>
<span class="fc" id="L704">        a = HH (a, b, c, d, x[13],   4, 0x289b7ec6); /* 41 */</span>
<span class="fc" id="L705">        d = HH (d, a, b, c, x[ 0],  11, 0xeaa127fa); /* 42 */</span>
<span class="fc" id="L706">        c = HH (c, d, a, b, x[ 3],  16, 0xd4ef3085); /* 43 */</span>
<span class="fc" id="L707">        b = HH (b, c, d, a, x[ 6],  23, 0x04881d05); /* 44 */</span>
<span class="fc" id="L708">        a = HH (a, b, c, d, x[ 9],   4, 0xd9d4d039); /* 45 */</span>
<span class="fc" id="L709">        d = HH (d, a, b, c, x[12],  11, 0xe6db99e5); /* 46 */</span>
<span class="fc" id="L710">        c = HH (c, d, a, b, x[15],  16, 0x1fa27cf8); /* 47 */</span>
<span class="fc" id="L711">        b = HH (b, c, d, a, x[ 2],  23, 0xc4ac5665); /* 48 */</span>
 
        /* Round 4 */
<span class="fc" id="L714">        a = II (a, b, c, d, x[ 0],   6, 0xf4292244); /* 49 */</span>
<span class="fc" id="L715">        d = II (d, a, b, c, x[ 7],  10, 0x432aff97); /* 50 */</span>
<span class="fc" id="L716">        c = II (c, d, a, b, x[14],  15, 0xab9423a7); /* 51 */</span>
<span class="fc" id="L717">        b = II (b, c, d, a, x[ 5],  21, 0xfc93a039); /* 52 */</span>
<span class="fc" id="L718">        a = II (a, b, c, d, x[12],   6, 0x655b59c3); /* 53 */</span>
<span class="fc" id="L719">        d = II (d, a, b, c, x[ 3],  10, 0x8f0ccc92); /* 54 */</span>
<span class="fc" id="L720">        c = II (c, d, a, b, x[10],  15, 0xffeff47d); /* 55 */</span>
<span class="fc" id="L721">        b = II (b, c, d, a, x[ 1],  21, 0x85845dd1); /* 56 */</span>
<span class="fc" id="L722">        a = II (a, b, c, d, x[ 8],   6, 0x6fa87e4f); /* 57 */</span>
<span class="fc" id="L723">        d = II (d, a, b, c, x[15],  10, 0xfe2ce6e0); /* 58 */</span>
<span class="fc" id="L724">        c = II (c, d, a, b, x[ 6],  15, 0xa3014314); /* 59 */</span>
<span class="fc" id="L725">        b = II (b, c, d, a, x[13],  21, 0x4e0811a1); /* 60 */</span>
<span class="fc" id="L726">        a = II (a, b, c, d, x[ 4],   6, 0xf7537e82); /* 61 */</span>
<span class="fc" id="L727">        d = II (d, a, b, c, x[11],  10, 0xbd3af235); /* 62 */</span>
<span class="fc" id="L728">        c = II (c, d, a, b, x[ 2],  15, 0x2ad7d2bb); /* 63 */</span>
<span class="fc" id="L729">        b = II (b, c, d, a, x[ 9],  21, 0xeb86d391); /* 64 */</span>
 
<span class="fc" id="L731">        state.state[0] += a;</span>
<span class="fc" id="L732">        state.state[1] += b;</span>
<span class="fc" id="L733">        state.state[2] += c;</span>
<span class="fc" id="L734">        state.state[3] += d;</span>
<span class="fc" id="L735">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.2.201302030002</span></div></body></html>